import chromadb
import openai
import os
import streamlit as st

from node import is_null
from utils import get_embedding

class RagAgent:
    def __init__(self):
        #Load chorma db from 'data' folder
        client = chromadb.PersistentClient(path="data/")
        self.db = client.get_collection(name="dental_history")
        self.recent_citations = {}
    
    def retrieve(self, query):
        hypothetical_answer = self.get_hypothetical_answer(query)

        query_result = self.query_chroma_db(hypothetical_answer, n_results=10)

        reranked_result = self.rerank_result(query_result, query)

        #only return the top 5 results
        reranked_result = reranked_result[:5]
        print('reranked result:', reranked_result)
        
        self.recent_citations = self.extract_citations(query_result, reranked_result)
        print('reranked citations:', self.recent_citations)

        contextual_result = self.get_additional_context(reranked_result, query_result)
        print('contextual result:', contextual_result)
        
        # summarized_result = self.summarize_context(contextual_result)
        summarized_result = contextual_result
        
        return summarized_result

    def get_response_stream(self, context: str) -> openai.ChatCompletion:
        """
        Retrieves course material relevant to the user's query and generates a response using OpenAI's GPT-4 model.

        Args:
            context (dict): A dictionary containing the user's query.

        Returns:
            response (OpenAI.ChatCompletion): A response generated by the GPT-4 model.
        """

        # Prepare chat history for openai
        self.chat_history = [ msg.openai_format() for msg in st.session_state.chat_history ]

        # Prepare system prompt
        system_prompt = {
            "role": "system",
            "content": f"""
            You are a teaching assistant for the course: 'History of Orthodontics with Dr. Lysle Johnston'. Your job is to help the user understand the course material.
            
            % Formatting Instructions %
            If you reference the quotes, only cite the numbers and always cite them individually in your response, like so: 'I have always supported dogs (1)(2).' or 'I have always supported dogs (1) and cats (2).'
            Limit your reponse to 300 words or less."""
        }
        
        result = self.retrieve(context)

        functions = [
            {
                "name": f"retrieve",
                "description": f"Returns quotes from the course material that are relevant to the query.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "query": {
                            "type": "string",
                            "description": f"The query to be answered. Example: 'What is the definition of orthodontics?'"
                        }
                    },
                    "required": ["query"]
                }
            }
        ]

        # call gpt-4 to generate a response
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[system_prompt]+self.chat_history+[
                {
                    "role": "function",
                    "name": "retrieve",
                    "content": result
                }
            ],
            stream=True,
            temperature=0,
            functions=functions
        )

        return response
    
    def get_hypothetical_answer(self, context: str) -> str:
        """
        Given the context, generate a hypothetical answer to the question
        Using openai's GPT-3-turbo-instruct model
        """
        system_prompt = {
            "role": "system",
            "content": "You are a teaching assistant for the course: 'History of Orthodontics with Dr. Lysle Johnston'. Your job is to answer questions about the course material. Please answer in 1 sentence or less."
        }
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[system_prompt]+self.chat_history
        )
        answer = response['choices'][0]['message']['content']
        return answer
    
    def query_chroma_db(self, hypothetical_answer: str, n_results: int) -> dict:
        """
        Returns the query result from the chroma db
        """
        embed = get_embedding(hypothetical_answer)
        result = self.db.query(embed, n_results=n_results, include=["metadatas", "documents"])
        return result

    def sort_query_result(self, query_result: dict) -> None:
        metadatas = query_result['metadatas'][0]
        documents = query_result['documents'][0]
        timestamps = [metadata['timestamp'] for metadata in metadatas]
        sorted_documents = [x for _,x in sorted(zip(timestamps, documents))]
        query_result['documents'][0] = sorted_documents
        sorted_metadatas = [x for _,x in sorted(zip(timestamps, metadatas))]
        sorted_ids = [x for _,x in sorted(zip(timestamps, query_result['ids'][0]))]

        query_result['metadatas'][0] = sorted_metadatas
        query_result['ids'][0] = sorted_ids
        query_result['documents'][0] = sorted_documents

    def structure_query_result(self, query_result: dict) -> str:
        """
        Join the documents with index numbers in the format: (1): ... \n (2): ... etc.
        """
        documents = query_result['documents'][0]
        structured_result = "\n".join([f"({i+1}): {documents[i]}" for i in range(len(documents))])
        return structured_result

    def rerank_result(self, query_result: str, query: dict) -> list[int]:
        """
        Reranks the search results based on the relevance to the user's query.

        Args:
        - query_result (str): The search results obtained from the search engine.
        - query (dict): The user's query.

        Returns:
        - answer (list[int]): A list of the most relevant quotes for the user's query, ordered by relevance.
        """
        context = self.structure_query_result(query_result)

        prompt=f"""
        You are a teaching assistant for the course: 'History of Orthodontics with Dr. Lysle Johnston'. Your job is to choose the most relevant quotes for the student's query. 
        
        The quotes are presented as "(1): ... \n \n (2):.... " etc. Please return a list of the numbers, starting with the most relevant quotes and ending with the least relevant quotes.

        <Begin Example>
        Query: What is the definition of orthodontics?
        Quotes:
        (1) Orthodontics is the branch of dentistry that deals with the prevention and correction of irregular teeth, as by means of braces or oral surgery, to improve the appearance, function, and health of the teeth and mouth.
        (2) Jam is good.
        (3) Orthodontics involves diagnosing and treating tooth and jaw abnormalities to correctly position teeth and jaws.
        Ranking: [1, 3, 2]
        <End Example>

        Query: {query}
        Quotes:
        """ + context + "\n\nRanking: "

        response = openai.Completion.create(
            model="gpt-3.5-turbo-instruct",
            prompt=prompt,
            temperature=0,
            max_tokens=100
        )

        text = response['choices'][0]['text']
        # parse the response
        answer = self.parse_reranked_result(text)
        # return the reranked result
        return answer

    def parse_reranked_result(self, text: str) -> list[int]:
        answer = text.replace('[', '')
        answer = answer.replace(']', '')
        answer = answer.replace(' ', '')
        answer = answer.split(',')
        answer = [int(i) for i in answer]
        return answer

    def get_additional_context(self, reranked_result: list[int], query_result: dict) -> str:
        """
        Given a reranked result and query result, returns a formatted string of the documents associated with each result.

        Args:
            reranked_result (list[int]): A list of integers representing the reranked results.
            query_result (dict): A dictionary containing the query results.

        Returns:
            str: A formatted string of the documents associated with each result.
        """
        ids = query_result['ids'][0]
        metadatas = query_result['metadatas'][0]
        documents = []

        for i in reranked_result:
            idx = i-1
            metadata_i = metadatas[idx]
            next_node = metadata_i['next']
            prev_node = metadata_i['prev']
            node_ids = [prev_node, ids[idx], next_node]
            filtered_ids = [node_id for node_id in node_ids if not is_null(node_id)]
            docs_i = self.db.get(filtered_ids, include=["documents"])['documents']
            documents.append(docs_i)

        #format documents
        final_context = []
        for idx, docrow in zip(reranked_result, documents):
            final_context.append(f'({idx}): "' + ' '.join(docrow) + '"')
        final_context = "\n".join(final_context)

        return final_context

    def extract_citations(self, query_result: dict, reranked_result: list[int]) -> dict:
        """
        Given the reranked result, extract the citations from the query result
        """
        metadatas = query_result['metadatas'][0]
        citations = {}
        for i in reranked_result:
            metadata_i = metadatas[i-1]
            video_id = metadata_i['video_id']
            timestamp = metadata_i['timestamp']
            citation_i = f'https://www.youtube.com/watch?v={video_id}&t={timestamp}'
            citations[str(i)] = citation_i
        return citations

    def get_recent_citations(self):
        return self.recent_citations

    def summarize_course(self) -> str:
        """
        Returns a precomunted summary of the course material.
        """
        #read in summary from file
        with open('data/summary.txt', 'r') as f:
            summary = f.read()
        return summary
        ...

    def generate_study_guide(self) -> str:
        """
        Generates a study guide for the course material, based on the user's chat history.
        """
        ...

    def generate_quiz(self) -> str:
        """
        Generates a quiz for the course material, based on the user's chat history.
        """
        ...

